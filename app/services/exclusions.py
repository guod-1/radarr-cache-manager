"""
Exclusion Manager

Handles generation and combination of mover exclusion files from multiple sources:
- Movies that don't meet high-rating criteria (from Radarr)
- Folder exclusions (from PlexCache folder_exclusions.txt)
- PlexCache-D exclusions (from unraid_mover_exclusions.txt)
"""

import logging
from pathlib import Path
from typing import List, Set
import os

from app.core.config import get_settings

logger = logging.getLogger(__name__)


class ExclusionManager:
    """Manages mover exclusion files"""
    
    def __init__(self):
        self.settings = get_settings()
    
    def add_exclusion(self, path: str):
        """Add a path to temporary exclusions (generic method)"""
        exclusions_file = self.settings.exclusions_file
        
        # Create parent directory if it doesn't exist
        exclusions_file.parent.mkdir(parents=True, exist_ok=True)
        
        # Append to file
        with open(exclusions_file, 'a') as f:
            f.write(f"{path}\n")
        
        logger.info(f"Added exclusion: {path}")
    
    def add_movie_exclusion(self, host_path: str):
        """Add a movie path to temporary exclusions (deprecated - use add_exclusion)"""
        self.add_exclusion(host_path)
    
    def read_exclusions_file(self, file_path: Path) -> List[str]:
        """Read lines from an exclusions file"""
        if not file_path.exists():
            logger.warning(f"Exclusions file not found: {file_path}")
            return []
        
        try:
            with open(file_path, 'r') as f:
                lines = f.readlines()
            return [line.strip() for line in lines if line.strip()]
        except Exception as e:
            logger.error(f"Error reading {file_path}: {e}")
            return []
    
    def convert_plexcache_paths(self, lines: List[str]) -> List[str]:
        """
        Convert PlexCache-D container paths to host paths
        
        /chloe/movies/ -> /mnt/chloe/data/media/movies/
        /chloe/tv/ -> /mnt/chloe/data/media/tv/
        """
        converted = []
        for line in lines:
            # Skip header lines
            if line == "### Plexcache exclusions below this line":
                continue
            
            # Convert paths
            converted_line = line.replace('/chloe/movies/', '/mnt/chloe/data/media/movies/')
            converted_line = converted_line.replace('/chloe/tv/', '/mnt/chloe/data/media/tv/')
            converted.append(converted_line)
        
        return converted
    
    def filter_redundant_entries(self, lines: List[str]) -> List[str]:
        """
        Remove redundant file entries when their parent directory is already excluded
        
        Example:
        /mnt/cache/movies/Movie1/
        /mnt/cache/movies/Movie1/movie.mkv  <- redundant, parent dir is excluded
        """
        parent_dirs: Set[str] = set()
        filtered_lines: List[str] = []
        
        for line in lines:
            if not line:
                continue
            
            # Check if it's a directory (no file extension in basename)
            if '.' not in os.path.basename(line):
                # It's a directory
                parent_dirs.add(line)
                filtered_lines.append(line)
            else:
                # It's a file - check if any parent directory is already excluded
                skip = any(line.startswith(parent_dir) for parent_dir in parent_dirs)
                if not skip:
                    filtered_lines.append(line)
        
        return filtered_lines
    
    def combine_exclusions(self) -> int:
        """
        Combine exclusions from all sources and write to mover_exclusions.txt
        
        Returns the number of final exclusion entries
        """
        logger.info("Combining exclusion files...")
        
        from app.core.config import get_user_settings
        user_settings = get_user_settings()
        
        combined_lines: List[str] = []
        
        # Read movie/custom exclusions (generated by operations)
        if self.settings.exclusions_file.exists():
            exclusions = self.read_exclusions_file(self.settings.exclusions_file)
            combined_lines.extend(exclusions)
            logger.info(f"Loaded {len(exclusions)} custom exclusions")
        
        # Read folder exclusions (if file exists)
        if self.settings.folder_exclusions_file.exists():
            folder_exclusions = self.read_exclusions_file(self.settings.folder_exclusions_file)
            combined_lines.extend(folder_exclusions)
            logger.info(f"Loaded {len(folder_exclusions)} folder exclusions")
        
        # Read and convert PlexCache-D exclusions
        plexcache_file = Path(user_settings.exclusions.plexcache_file_path)
        if plexcache_file.exists():
            plexcache_exclusions = self.read_exclusions_file(plexcache_file)
            converted_exclusions = self.convert_plexcache_paths(plexcache_exclusions)
            combined_lines.extend(converted_exclusions)
            logger.info(f"Loaded {len(converted_exclusions)} PlexCache-D exclusions")
        else:
            logger.warning(f"PlexCache file not found: {plexcache_file}")
        
        # Filter redundant entries
        filtered_lines = self.filter_redundant_entries(combined_lines)
        logger.info(f"Filtered to {len(filtered_lines)} unique entries")
        
        # Write combined exclusions
        with open(self.settings.exclusions_file, 'w') as f:
            for line in filtered_lines:
                f.write(f"{line}\n")
        
        logger.info(f"Combined exclusions written to {self.settings.exclusions_file}")
        return len(filtered_lines)
    
    def clear_temp_exclusions(self):
        """Clear temporary exclusions file"""
        if self.settings.exclusions_file.exists():
            self.settings.exclusions_file.unlink()
            logger.info("Cleared temporary exclusions file")
    
    def get_exclusion_stats(self) -> dict:
        """Get statistics about exclusions"""
        if not self.settings.exclusions_file.exists():
            return {
                'total': 0,
                'files': 0,
                'directories': 0
            }
        
        lines = self.read_exclusions_file(self.settings.exclusions_file)
        files = sum(1 for line in lines if '.' in os.path.basename(line))
        directories = len(lines) - files
        
        return {
            'total': len(lines),
            'files': files,
            'directories': directories
        }


def get_exclusion_manager() -> ExclusionManager:
    """Dependency for FastAPI routes"""
    return ExclusionManager()
